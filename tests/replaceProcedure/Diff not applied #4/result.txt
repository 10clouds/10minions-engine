import { MinionTask } from "../../MinionTask";
import { APPLIED_STAGE_NAME, APPLYING_STAGE_NAME, FINISHED_STAGE_NAME } from "../../ui/MinionTaskUIInfo";
import { decomposeMarkdownString } from "./decomposeMarkdownString";
import { applyModificationProcedure } from "./applyModificationProcedure";
import { convertUri } from "../../vscode/vscodeUtils";
import { getEditorManager } from "../../managers/EditorManager";

/* Function to set task progress */
  function setTaskProgress(minionTask:MinionTask, stageName: string, progress: number) {
    minionTask.executionStage = stageName;
    minionTask.progress = progress;
    minionTask.onChanged(true);
  }

  /* Function to display message */
  function displayMessage(messageType: string, message: string) {
    if(messageType === 'error') {
      getEditorManager().showErrorMessage(message);
    } else {
      getEditorManager().showInformationMessage(message);
    }
  }

  /* Function to apply error fallback */
  export async function applyErrorFallback(minionTask: MinionTask) {
    const document = await minionTask.document();
    const language = document.languageId || "javascript";

    const decomposedString = decomposeMarkdownString(
      `
  Task: ${minionTask.userQuery}

  ${minionTask.modificationDescription}
  `.trim(),
      language
    ).join("\n");

    minionTask.appendToLog(`\nPLAIN COMMENT FALLBACK\n`);

    minionTask.originalContent = document.getText();

    setTaskProgress(minionTask, APPLYING_STAGE_NAME, 0);

    await getEditorManager().applyWorkspaceEdit(async (edit) => {
      edit.insert(convertUri(minionTask.documentURI), { line: 0, character: 0 }, decomposedString + "\n");
    });

    setTaskProgress(minionTask, APPLIED_STAGE_NAME, 1);
    minionTask.contentAfterApply = document.getText();
    minionTask.appendToLog(`Applied modification as plain top comments\n\n`);
    displayMessage('success', `Modification applied successfully.`);
  }

/* Moved the try-catch block into a new function */
  async function handleModification(minionTask: MinionTask, modification:string) {
      try{
        if (!minionTask.modificationProcedure) {
          throw new Error(`Modification procedure is empty.`);
        }

        let document = await minionTask.document();
        let currentDocContent = document.getText();

        if (minionTask.contentAfterApply === currentDocContent) {
          setTaskProgress(minionTask, APPLIED_STAGE_NAME, 1);
          displayMessage('error', `Already applied.`);
          return;
        }

        minionTask.originalContent = currentDocContent;

        let preprocessedContent = minionTask.originalContent;

        let modifiedContent = await applyModificationProcedure(
          preprocessedContent,
          minionTask.modificationProcedure,
          document.languageId,
        );

        console.log(`modifiedContent: "${modifiedContent}"`);

        await getEditorManager().applyWorkspaceEdit(async (edit) => {
          edit.replace(
            convertUri(document.uri),
            {
              start: { line: 0, character: 0},
              end: { line: document.lineCount - 1, character: document.lineAt(document.lineCount - 1).text.length}
            },
            modifiedContent
          );
        });

        setTaskProgress(minionTask, APPLIED_STAGE_NAME, 1);
        minionTask.contentAfterApply = document.getText();
        minionTask.appendToLog(`Applied changes for user review.\n\n`);
        displayMessage('success', `Modification applied successfully.`);
      } catch(error){
        console.log(`Failed to apply modification: ${String(error)}`);
        applyErrorFallback(minionTask);
      }
  }

  export async function applyMinionTask(minionTask: MinionTask) {
    if (minionTask.executionStage !== FINISHED_STAGE_NAME) {
      displayMessage('error', `Cannot apply unfinished task.`);
      return;
    }
  
    setTaskProgress(minionTask, APPLYING_STAGE_NAME, 0);

    handleModification(minionTask, minionTask.modificationProcedure);
  }


/*
Recently applied task: Add this not at the start, but at the first edditing position.
*/
